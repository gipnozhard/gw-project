# ==============================================
# Билд-стадия (builder) - сборка Go-приложения
# ==============================================

# Базовый образ с Go 1.24.1 на Alpine Linux (минималистичный дистрибутив)
# AS builder - именуем эту стадию для многоступенчатой сборки
FROM golang:1.24.1-alpine AS builder

# Устанавливаем рабочую директорию в контейнере
WORKDIR /app

# Копируем ВЕСЬ проект в контейнер (включая go.mod, go.sum и исходники)
# Важно: копируем до загрузки зависимостей для эффективного кэширования
COPY . .

# Переходим в директорию сервиса exchanger
WORKDIR /app/gw-exchanger

# Загружаем зависимости Go (кэшируется, если не менялись go.mod/go.sum)
# Используем download вместо tidy для воспроизводимости сборки
RUN go mod download

# Компилируем приложение с параметрами для production:
# - CGO_ENABLED=0 - статическая сборка без зависимостей от C
# - GOOS=linux - целевая ОС
# - ./cmd/main.go - точка входа приложения
# - -o /app/bin/exchanger - выходной файл бинарника
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/bin/exchanger ./cmd/main.go

# ==============================================
# Финальная стадия - минимальный образ для запуска
# ==============================================

# Чистый образ Alpine Linux (всего ~5MB)
FROM alpine:latest

# Рабочая директория приложения
WORKDIR /app

# Создаем директорию для миграций БД
RUN mkdir -p migrations

# Копируем из стадии builder:
# 1. Скомпилированный бинарник
COPY --from=builder /app/bin/exchanger .
# 2. Конфигурационный файл
COPY --from=builder /app/gw-exchanger/config.env .
# 3. SQL-миграции в отдельную директорию
COPY --from=builder /app/gw-exchanger/migrations ./migrations/

# Декларируем используемый порт (для документации)
# Фактическое пробрасывание делается в docker-compose.yml
EXPOSE 50051

# Команда запуска приложения (формат JSON-массива предпочтителен)
CMD ["./exchanger"]